Cloud
=====

We use :ref:`AWS-EC2-label` as our principle production cloud environment, and
:ref:`Vagrant-AWS-label` to manage it.


.vagrant/
---------

Using Vagrant and vagrant-pirate_ we can specify our various VM types in
available.d/, and then control which are built by symlinking to them in
enabled.d. Instance-specific overrides (such as hostnames) go in local.d.

Vagrant keeps track of instances it creates in the project's .vagrant/. This
directory is generated by Vagrant and has a structure like this:

::

    $ tree .vagrant/
    .vagrant/
    └── machines
        ├── ci.getvalkyrie.com
        │   ├── aws
        │   │   ├── action_provision
        │   │   ├── id
        │   │   └── index_uuid
        │   └── virtualbox
        └── default
            └── virtualbox

We're interested in the contents of .vagrant/machines/<machine_name>/aws/, as
this stores the Amazon machine ID, and thus allows the on-going control of
provisioned systems. On the other hand, the virtualbox/ directories are of
almost no use, since they'll only point to local machines.

In a private git repo, we'll want to ship our private SSH keys, as well. Along
with the AWS instances IDs in .vagrant, we now have a portable configuration
for our entire cloud infrastructure.

.. _vagrant-pirate: http://github.com/PraxisLabs/vagrant-pirate.git


Environments
------------

Branches in this git repo should represent environments. Our 'prod' branch
should contain the references to our production EC2 instances, whereas other
branches can be used to build up test environments. By not specifying
'--provider=aws' when building a project, Vagrant will default to using
Virtualbox which should work equally well for local development and testing.

We'll need to be careful not to use the references in the production .vagrant/
for testing, and also to keep various distributed copies of this repo in sync.
To that end, we should probably wrap our regular workflows in a Makefile, to
help ensure this consistency. Alternatively, or in addition, we should consider
writing (or finding) a Vagrant plug-in to consistently run 'git pull' or
similar whenever a Vagrant command is run.
